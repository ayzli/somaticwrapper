######### Song Cao and Matt Wyczalkowski ###########
## pipeline for somatic variant calling ##

#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Basename;

#use POSIX;
my $version = 3.0;

# submodule information
# https://stackoverflow.com/questions/1712016/how-do-i-include-functions-from-another-file-in-my-perl-script
require('src/run_strelka.pl');
require("src/run_varscan.pl");
require("src/parse_strelka.pl");
require("src/parse_varscan.pl");
require("src/run_pindel.pl");
require("src/parse_pindel.pl");
require("src/merge_vcf.pl");
require("src/annotate_vcf.pl");

(my $usage = <<OUT) =~ s/\t+//g;
This script will evaluate variants for WGS and WXS data
Pipeline version: $version
Usage: perl $0 [options] step_number 

step_number executes given step of pipeline:
* [1 or run_strelka]  Run streka
* [2 or run_varscan]  Run Varscan
* [3 or parse_strelka]  Parse streka result
* [4 or parse_varscan]  Parse VarScan result
* [5 or run_pindel]  Run Pindel
* [7 or parse_pindel]  Parse Pindel
* [8 or merge_vcf]  Merge vcf files 
* [10 or annotate_vcf]  Run VEP annotation on a given file

Configuration file parameters [defaults]
    --tumor_bam s:  path to tumor BAM.  Required for all runs
    --normal_bam s: path to normal BAM.  Required for all runs
    --reference_fasta s: path to reference
    --assembly s: either "GRCh37" or "GRCh38", used for VEP [GRCh37]
    --vep_cache_version s: Cache version, e.g. '90', used for VEP.  Required if using vep cache
    --reference_dict s: path to reference dict file.  Default is reference_fasta with ".dict" appended
    --sw_dir s: Somatic Wrapper installation directory [/usr/local/somaticwrapper]
    --results_dir s: Per-sample analysis results written to results_dir; a relative directory, often same as sample name [.] 
    --vep_cache_dir s: define location of VEP cache directory. If not defined, will perform online VEP DB lookups.  
          Online VEP database lookups ("use_vep_db") a) uses online database (so cache isn't installed) b) does not use tmp files
          It is meant to be used for testing and lightweight applications.  Use the cache for better performance.
          See discussion: https://www.ensembl.org/info/docs/tools/vep/script/vep_cache.html 
    --vep_cache_gz s: extract contents of .tar.gz vep cache tree into vep_cache_dir, or "./vep-cache" if vep_cache_dir not specified
    --output_vep : if defined, write final annotated merged file in VEP rather than VCF format
    --no_delete_temp : if defined, do not delete temp files in run_pindel and parse_pindel
    --strelka_config s: path to strelka.ini file, required for strelka run
    --varscan_config s: path to varscan.ini file, required for varscan run and parse
    --pindel_config s: path to pindel.ini file, required for pindel parsing
    --centromere_bed s: path to BED file describing centromere regions to exclude for pindel analysis.  See C_Centromeres for discussion
    --gatk_jar s: path to GATK Jar file.  [/usr/local/GenomeAnalysisTK-3.8-0-ge9d806836/GenomeAnalysisTK.jar]
    --perl s: path to PERL executable.  [/usr/bin/perl]
    --strelka_dir s: path to strelka installation dir.  [/usr/local/strelka]
    --vep_cmd s: path to ensembl vep executable.  [/usr/local/ensembl-vep/vep]
    --pindel_dir s: path to Pindel installation dir.  [/usr/local/pindel]
    --snpsift_jar s: [/usr/local/snpEff/SnpSift.jar]
    --varscan_jar s: [/usr/local/VarScan.jar]
    --dbsnp_db s: database for dbSNP filtering.  Required
    --strelka_snv_raw s: SNV output file generated by Stelka run.  Required for parse_strelka
    --varscan_indel_raw s: Indel output file generated by varscan run.  Required for parse_varscan
    --varscan_snv_raw s: SNV output file generated by varscan run.  Required for parse_varscan
    --pindel_raw s: raw output file generated by pindel run.  Required for parse_pindel
    --strelka_snv_vcf s: output file generated by parse_strelka.  Required for merge_vcf
    --varscan_snv_vcf s: output file generated by parse_varscan.  Required for merge_vcf
    --varscan_indel_vcf s: output file generated by parse_varscan.  Required for merge_vcf
    --pindel_vcf s: output file generated by parse_pindel.  Required for merge_vcf
    --input_vcf s: VCF file to be annotated with annotate_vcf
    --is_strelka2: run stelka2 instead of strelka version 1
    --strelka_vcf_filter_config: Configuration file for strelka VCF filtering (depth, VAF, read count)
    --varscan_vcf_filter_config: Configuration file for varscan VCF filtering 
    --pindel_vcf_filter_config: Configuration file for pindel VCF filtering 

Note that logic of boolean arguments can be reversed with "no" prefix, e.g. --nois_strelka2 
OUT

# Argument parsing reference: http://perldoc.perl.org/Getopt/Long.html
# https://perlmaven.com/how-to-process-command-line-arguments-in-perl
my $tumor_bam;
my $normal_bam;
my $assembly;
my $vep_cache_version;
my $reference_fasta;
my $reference_dict;  # default mapping occurs after reference_fasta known
my $sw_dir = "/usr/local/somaticwrapper";
my $results_dir = ".";  
my $vep_cache_dir;
my $vep_cache_gz;
my $output_vep;     # Boolean
my $is_strelka2;    # Boolean
my $no_delete_temp; # Boolean
my $strelka_config; 
my $varscan_config; 
my $pindel_config; 
my $centromere_bed; 
my $gatk_jar = "/usr/local/GenomeAnalysisTK-3.8-0-ge9d806836/GenomeAnalysisTK.jar";
my $perl = "/usr/bin/perl";
my $strelka_dir = "/usr/local/strelka";
my $strelka2_dir = "/usr/local/strelka2";
my $vep_cmd = "/usr/local/ensembl-vep/vep";
my $pindel_dir = "/usr/local/pindel";
my $snpsift_jar = "/usr/local/snpEff/SnpSift.jar";
my $varscan_jar = "/usr/local/VarScan.jar";
my $dbsnp_db;
my $strelka_snv_raw;
my $varscan_indel_raw;
my $varscan_snv_raw;
my $pindel_raw;
my $strelka_snv_vcf;
my $varscan_snv_vcf;
my $varscan_indel_vcf;
my $pindel_vcf;
my $input_vcf;
my $strelka_vcf_filter_config; 
my $varscan_vcf_filter_config; 
my $pindel_vcf_filter_config;

GetOptions(
    'tumor_bam=s' => \$tumor_bam,
    'normal_bam=s' => \$normal_bam,
    'reference_fasta=s' => \$reference_fasta,
    'assembly=s' => \$assembly,
    'vep_cache_version=s' => \$vep_cache_version,
    'reference_dict=s' => \$reference_dict,
    'sw_dir=s' => \$sw_dir,
    'results_dir=s' => \$results_dir,
    'vep_cache_dir=s' => \$vep_cache_dir,
    'vep_cache_gz=s' => \$vep_cache_gz,
    'strelka_config=s' => \$strelka_config,
    'varscan_config=s' => \$varscan_config,
    'pindel_config=s' => \$pindel_config,
    'centromere_bed=s' => \$centromere_bed,
    'gatk_jar=s' => \$gatk_jar,
    'perl=s' => \$perl,
    'strelka_dir=s' => \$strelka_dir,
    'strelka2_dir=s' => \$strelka2_dir,
    'vep_cmd=s' => \$vep_cmd,
    'pindel_dir=s' => \$pindel_dir,
    'snpsift_jar=s' => \$snpsift_jar,
    'varscan_jar=s' => \$varscan_jar,
    'dbsnp_db=s' => \$dbsnp_db,
    'strelka_snv_raw=s' => \$strelka_snv_raw,
    'varscan_indel_raw=s' => \$varscan_indel_raw,
    'varscan_snv_raw=s' => \$varscan_snv_raw,
    'pindel_raw=s' => \$pindel_raw,
    'strelka_snv_vcf=s' => \$strelka_snv_vcf,
    'varscan_snv_vcf=s' => \$varscan_snv_vcf,
    'pindel_vcf=s' => \$pindel_vcf,
    'varscan_indel_vcf=s' => \$varscan_indel_vcf,
    'input_vcf=s' => \$input_vcf,
    'output_vep!' => \$output_vep,
    'no_delete_temp!' => \$no_delete_temp,
    'is_strelka2!' => \$is_strelka2,
    'strelka_vcf_filter_config=s' => \$strelka_vcf_filter_config,
    'varscan_vcf_filter_config=s' => \$varscan_vcf_filter_config,
    'pindel_vcf_filter_config=s' => \$pindel_vcf_filter_config,
) or die "Error parsing command line args.\n$usage\n";

die $usage unless @ARGV >= 1;
my ( $step_number ) = @ARGV;

# Distinguising between location of modules of somatic wrapper and GenomeVIP
# GenomeVIP is not distributed separately so hard code the path
my $gvip_dir="$sw_dir/GenomeVIP";
my $filter_dir="$sw_dir/vcf_filters";

# automatically generated scripts in runtime
my $job_files_dir="$results_dir/runtime";  # OUTPUT PORT
system("mkdir -p $job_files_dir");

#print("Using reference $reference_fasta\n");
print("SomaticWrapper dir: $sw_dir \n");
print("Analysis dir: $results_dir\n");
print("Run script dir: $job_files_dir\n");

# Not clear when this would be needed...
#if ( not $reference_dict ) { $reference_dict = "$reference_fasta.dict";}

if (($step_number eq '1') || ($step_number eq 'run_strelka')) {
    die("tumor_bam undefined \n") unless $tumor_bam;
    die("normal_bam undefined \n") unless $normal_bam;
    die("strelka_config undefined \n") unless $strelka_config;
    die("reference_fasta undefined \n") unless $reference_fasta;

    print("strelka_config: $strelka_config\n");

    my $strelka_bin;
    if ($is_strelka2) {
        print("Running Strelka 2\n");
        $strelka_bin="$strelka2_dir/bin/configureStrelkaSomaticWorkflow.py";
    } else {
        print("Running Strelka 1\n");
        $strelka_bin="$strelka_dir/bin/configureStrelkaWorkflow.pl";
    }

    # switching 1->2 is more than just changing $strelka_dir, since the script name changes too.
    # have $strelka_dir and $strelka2_dir
    # have --strelka_version values 1 or 2
    # --exome is based on strelka.ini

    run_strelka($tumor_bam, $normal_bam, $results_dir, $job_files_dir, $strelka_bin, $reference_fasta, $strelka_config, $is_strelka2);
} elsif (($step_number eq '2') || ($step_number eq 'run_varscan')) {
    die("tumor_bam undefined \n") unless $tumor_bam;
    die("normal_bam undefined \n") unless $normal_bam;
    die("varscan_config undefined \n") unless $varscan_config;
    die("reference_fasta undefined \n") unless $reference_fasta;
    run_varscan($tumor_bam, $normal_bam, $results_dir, $job_files_dir, $reference_fasta, $varscan_config, $varscan_jar);
} elsif (($step_number eq '3') || ($step_number eq 'parse_strelka')) {
    die("Strelka SNV Raw input file not specified \n") unless $strelka_snv_raw;
    die("strelka_config undefined \n") unless $strelka_config;
    die("strelka_vcf_filter_config undefined \n") unless $strelka_vcf_filter_config;
    parse_strelka($results_dir, $job_files_dir, $perl, $gvip_dir, $filter_dir, $dbsnp_db, $snpsift_jar, $strelka_snv_raw, $strelka_vcf_filter_config);
} elsif (($step_number eq '4') || ($step_number eq 'parse_varscan')) {
    die("Varscan Indel Raw input file not specified \n") unless $varscan_indel_raw;
    die("Varscan SNV Raw input file not specified \n") unless $varscan_snv_raw;
    die("varscan_config undefined \n") unless $varscan_config;
    die("varscan_vcf_filter_config undefined \n") unless $varscan_vcf_filter_config;
    parse_varscan($results_dir, $job_files_dir, $perl, $gvip_dir, $filter_dir, $dbsnp_db, $snpsift_jar, $varscan_jar, $varscan_indel_raw, $varscan_snv_raw, $varscan_config, $varscan_vcf_filter_config);
} elsif (($step_number eq '5') || ($step_number eq 'run_pindel')) {
    die("tumor_bam undefined \n") unless $tumor_bam;
    die("normal_bam undefined \n") unless $normal_bam;
    die("reference_fasta undefined \n") unless $reference_fasta;
    run_pindel($tumor_bam, $normal_bam, $results_dir, $job_files_dir, $reference_fasta, $pindel_dir, $centromere_bed, $no_delete_temp);
} elsif (($step_number eq '7') || ($step_number eq 'parse_pindel')) {
    die("pindel_config undefined \n") unless $pindel_config;
    die("pindel raw input file not specified \n") unless $pindel_raw;
    die("reference_fasta undefined \n") unless $reference_fasta;
    die("pindel_vcf_filter_config undefined \n") unless $pindel_vcf_filter_config;
    parse_pindel($results_dir, $job_files_dir, $reference_fasta, $perl, $gvip_dir, $filter_dir, $pindel_dir, $dbsnp_db, $snpsift_jar, $pindel_config, $pindel_raw, $no_delete_temp, $pindel_vcf_filter_config);
} elsif (($step_number eq '8') || ($step_number eq 'merge_vcf')) {
    die("strelka_snv_vcf undefined \n") unless $strelka_snv_vcf;
    die("varscan_snv_vcf undefined \n") unless $varscan_snv_vcf;
    die("pindel_vcf undefined \n") unless $pindel_vcf;
    die("varscan_indel_vcf undefined \n") unless $varscan_indel_vcf;
    die("reference_fasta undefined \n") unless $reference_fasta;

    merge_vcf($results_dir, $job_files_dir, $filter_dir, $reference_fasta, $gatk_jar, $strelka_snv_vcf, $varscan_indel_vcf, $varscan_snv_vcf, $pindel_vcf);
} elsif (($step_number eq '10') || ($step_number eq 'annotate_vcf')) {
    die("assembly undefined \n") unless $assembly;
    die("input_vcf undefined \n") unless $input_vcf;
    die("reference_fasta undefined \n") unless $reference_fasta;
    annotate_vcf($results_dir, $job_files_dir, $reference_fasta, $gvip_dir, $vep_cmd, $assembly, $vep_cache_version, $vep_cache_dir, $vep_cache_gz, $output_vep, $input_vcf)
} else {
    die("Unknown step number $step_number\n");
}
